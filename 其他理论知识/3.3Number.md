### **Number**类型

​ ECMAScript 中最有意思的数据类型或许就是 Number 了。Number 类型使用 **IEEE 754** 格式表示**整数和浮点值**(在某些语言中也叫**双精度值**)。不同的数值类型相应地也有不同的数值字面量格式。

​ 最基本的数值字面量格式是十进制整数，直接写出来即可:

​ `let intNum = 55; // 整数`

​ 整数也可以用八进制(以 8 为基数)或十六进制(以 16 为基数)字面量表示。对于八进制字面量， **第一个数字必须是零**(0)，然后是相应的**八进制数字**(数值 0~7)。如果字面量中包含的数字**超出**了应有的范围，就会**忽略前缀的零**，后面的数字序列会被当成**十进制数**，如下所示:

```javascript
let octalNum1 = 070; // 八进制的56
let octalNum2 = 079; //无效的八进制值，当成79处理
let octalNum3 = 08; // 无效的八进制值，当成 8 处理
```

​ 八进制**字面量**在**严格模式**下是**无效**的，会导致 JavaScript 引擎抛出语法错误。

> ECMAScript 2015 或 ES6 中的八进制值通过前缀 0o 来表示;严格模式下，前缀 0 会被视为语法错误，如果要表示 八进制值，应该使用前缀 0o。

​ 要创建十六进制字面量，必须让真正的数值前缀 0x(**区分大小写**)，然后是十六进制数字(0~9 以 及 A~F)。十六进制数字中的**字母大小写均可**。下面是几个例子:

```javascript
let hexNum1 = 0xa; // 十六进制10
let hexNum2 = 0x1f; // 十六进制31
```

​ 使用八进制和十六进制格式创建的数值在所有**数学操作**中都被视为十进制数值。

> **注意** 由于 JavaScript 保存数值的方式，实际中可能存在**正零**(+0)和**负零**(-0)。正零和 负零在所有情况下都被认为是**等同**的，这里特地说明一下。

    #### 浮点值

​ 要定义浮点值，数值中**必须包含小数点**，而且小数点后面必须**至少有一个数字**。虽然小数点**前面不是必须有整数**，但推荐加上。下面是几个例子:

```javascript
let floatNum1 = 1.1;
let floatNum2 = 0.1;
let floatNum3 = 0.1; // 有效，但不推荐
```

​ 因为存储浮点值使用的内存空间是存储整数值的**两倍**，所以 ECMAScript 总是想方设法把值**转换为整数**。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小 数点后面跟着 0(如 1.0)，那它也会被转换为整数，如下例所示:

```javascript
let floatNum1 = 1; // 小数点后面没有数字，当成整数 1 处理
let floatNum2 = 10.0; // 小数点后面是零，当成整数 10 处理
```

​ 对于非常大或非常小的数值，浮点值可以用**科学记数法**来表示。科学记数法用于表示一个应该乘以 10 的给定次幂的数值。ECMAScript 中科学记数法的格式要求是**一个数值**(整数或浮点数)后跟一个**大 写**或**小写**的**字母 e**，再加上一个要乘的 10 的多少次幂。比如:

​ `let floatNum = 3.125e7; // 等于31250000`

​ 在这个例子中，floatNum 等于 31 250 000，只不过科学记数法显得**更简洁**。这种表示法实际上相 当于说:“以 3.125 作为**系数**，乘以 10 的 7 次**幂**。”

​ 科学记数法也可以用于表示非常小的数值，例如 0.000 000 000 000 000 03。这个数值用科学记数法表示为 3e-17。**默认情况**下，ECMAScript 会将小数点后至少包含 **6 个零**的**浮点值**转换为科学记数法(例如，0.000 000 3 会被转换为 3e-7)。

​ 浮点值的精确度最高可达 **17 位**小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不是 0.3，而是 0.300 000 000 000 000 04。由于这种微小的**舍入错误**，导致很难测试**特定**的浮点值。比如下 面的例子:

```javascript
let a = 0.1,
  b = 0.2;
console.log(a + b); //0.30000000000000004
if (a + b == 0.3) {
  // 别这么干!
  console.log("You got 0.3.");
}
```

​ 这里检测两个数值之和是否等于 0.3。如果两个数值分别是 0.05 和 0.25，或者 0.15 和 0.15，那没问 题。但如果是 0.1 和 0.2，如前所述，测试将失败。因此永远不要测试某个特定的浮点值。

> **注意** 之所以存在这种舍入错误，是因为使用了**IEEE754 数值**，这种错误并非 ECMAScript 所**独有**。其他使用相同格式的语言也有这个问题。

#### 值的范围

​ 由于**内存**的限制，ECMAScript 并**不支持**表示这个世界上的所有数值。ECMAScript 可以表示的最小数值保存在**Number.MIN_VALUE**中，这个值在**多数浏览器**中是 5e-324;可以表示的最大数值保存在 **Number.MAX_VALUE** 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果**超出**了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 **Infinity**(无 穷)值。任何无法表示的负数以**-Infinity**(负无穷大)表示，任何无法表示的正数以 **Infinity**(正 无穷大)表示。

​ 如果计算返回正 Infinity 或负 Infinity，则该值将**不能再进一步**用于**任何计算**。这是因为 Infinity 没有可用于计算的数值表示形式。要确定一个值是不是**有限大**(即介于 JavaScript 能表示的 最小值和最大值之间)，可以使用 **isFinite**()函数，如下所示:

```javascript
let result = Number.MAX_VALUE + Number.MAX_VALUE;
console.log(isFinite(result)); // false
```

​ 虽然超出有限数值范围的计算并不多见，但总归还是有可能的。因此在计算**非常大或非常小**的数值时，有必要**监测**一下计算结果是否**超出范围**。

> 注意 使用**Number.NEGATIVE_INFINITY**和**Number.POSITIVE_INFINITY**也可以获取正、负 Infinity。没错，这两个属性包含的值分别就是-Infinity 和 Infinity。

#### NaN

​ 有一个特殊的数值叫 NaN，意思是“不是数值”(Not a Number)，用于表示本来要返回数值的操作失败了(而不是抛出错误)。比如，用 **0 除任意数值**在其他语言中**通常都会导致错误**，从而**中止代码**执行。但在 ECMAScript 中，0、+0 或-0 相除会返回 NaN:

```javascript
console.log(0 / 0); // NaN
console.log(-0 / +0); // NaN
```

​ 如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 Infinity 或-Infinity:

```javascript
console.log(5 / 0); // Infinity
console.log(5 / -0); // -Infinity
```

​ NaN 有几个独特的属性。首先，任何涉及 NaN 的操作**始终返回** NaN(如 NaN/10)，在连续多步计算时这可能是个问题。其次，NaN **不等于**包括 NaN 在内的任何值。例如，下面的比较操作会返回 false:

```javascript
console.log(NaN == NaN); // false
```

​ 为此，ECMAScript 提供了 **isNaN**()函数。该函数接收一个参数，可以是**任意数据类型**，然后判断 这个参数是否“不是数值”。把一个值传给 isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串"10"或布尔值。任何**不能转换为数值**的值都会导致这个函数返回 true。举例如下:

```javascript
console.log(isNaN(NaN)); // true
console.log(isNaN(10)); // false，10 是数值
console.log(isNaN("10")); // false，可以转换为数值10
console.log(isNaN("blue")); // true，不可以转换为数值
console.log(isNaN(true)); // false，可以转换为数值1
```

​ 上述的例子测试了 5 个不同的值。首先测试的是 NaN 本身，显然会返回 true。接着测试了数值 10 和字符串"10"，都返回 false，因为它们的数值都是 10。字符串"blue"不能转换为数值，因此函数返 回 true。布尔值 true 可以转换为数值 1，因此返回 false。

> **注意** 虽然不常见，但 isNaN()可以用于**测试对象**。此时，首先会调用对象的**valueOf**() 方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 **toString**()方法， 并测试其返回值。这通常是 ECMAScript **内置函数**和**操作符**的工作方式，本章后面会讨论。

#### 数值转换

​ 有 3 个函数可以将非数值转换为数值:Number()、parseInt()和 parseFloat()。Number()是**转型函数**，可用于任何数据类型。后两个函数主要用于将**字符串**转换为数值。对于同样的参数，这 3 个 函数执行的操作也不同。

​ Number()函数基于如下规则执行转换。

- 布尔值，true 转换为 1，false 转换为 0。
- 数值，直接返回。
- null，返回 0。
- undefined，返回 NaN。
- 字符串，应用以下规则。
  - 如果字符串**包含**数值字符，包括**数值字符**前面**带加、减号**的情况，则转换为一个**十进制**数值。 因此，Number("1")返回 1，Number("123")返回 123，Number("011")返回 11(忽略前面 的零)。
  - 如果字符串包含有效的浮点值格式如"1.1"，则会转换为相应的浮点值(同样，忽略前面的零)。
  - 如果字符串包含有效的十六进制格式如"0xf"，则会转换为与该十六进制值**对应**的十进制整数值。
  - 如果是空字符串(不包含字符)，则返回 0。
  - 如果字符串包含除上述情况之外的其他字符，则返回 NaN。
- 对象，调用 **valueOf**()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 **toString**()方法，再按照转换**字符串**的规则转换。

​ 从不同数据类型到数值的转换有时候会比较复杂，看一看 Number()的转换规则就知道了。下面是 几个具体的例子:

```javascript
let num1 = Number("Hello world!"); // NaN
let num2 = Number(""); //0
let num3 = Number("000011"); // 11
let num4 = Number(true); //1
let test = Number({ a: "123" }); //NaN
```

​ 可以看到，字符串"Hello world"转换之后是 NaN，因为它找不到对应的数值。空字符串转换后是 0。字符串 000011 转换后是 11，因为前面的零被忽略了。最后，true 转换为 1。

> 注意 本章后面会讨论到的**一元加操作符**与**Number()**函数遵循**相同**的转换规则。

    考虑到用 Number()函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使

用 parseInt()函数。parseInt()函数更专注于字符串是否包含**数值模式**。字符串最前面的**空格会被忽略**，从第一个**非空格字符**开始转换。如果第一个字符**不是数值字符、加号或减号**，parseInt()立即返回 NaN。这意味着空字符串也会返回 NaN(这一点跟 Number()不一样，它返回 0)。如果第一个字符是数值字符、加号或减号，则**继续**依次检测每个字符，直到字符串**末尾**，或碰到**非数值**字符。比如， "1234blue"会被转换为 1234，因为"blue"会被完全忽略。类似地，"22.5"会被转换为 22，因为小数点不是有效的整数字符。

​ 假设字符串中的第一个字符是数值字符，parseInt()函数也能识别不同的整数格式(十进制、八 进制、十六进制)。换句话说，如果字符串以"0x"开头，就会被解释为十六进制整数。如果字符串以"0" 开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。

​ 下面几个转换示例有助于理解上述规则:

```javascript
let num1 = parseInt("1234blue"); // 1234
let num2 = parseInt(""); // NaN
let num3 = parseInt("0xA"); // 10，解释为十六进制整数
let num4 = parseInt(22.5); // 22
let num5 = parseInt("70"); // 70，解释为十进制值
let num6 = parseInt("0xf"); // 15，解释为十六进制整数
```

​ 不同的数值格式很容易混淆，因此 parseInt()也接收**第二个参数**，用于指定**底数(进制数)**。如 果知道要解析的值是十六进制，那么可以传入 16 作为第二个参数，以便正确解析:

​ `let num = parseInt("0xAF", 16); // 175`

​ 事实上，如果提供了十六进制参数，那么字符串前面的"0x"可以省掉:

```javascript
let num1 = parseInt("AF", 16); // 175
let num2 = parseInt("AF"); // NaN
```

​ 在这个例子中，第一个转换是正确的，而第二个转换失败了。区别在于第一次传入了进制数作为参 数，告诉 parseInt()要解析的是一个十六进制字符串。而第二个转换检测到第一个字符就是非数值字符，随即自动停止并返回 NaN。

​ 通过第二个参数，可以极大扩展转换后获得的结果类型。比如:

```javascript
let num1 = parseInt("10", 2); // 2，按二进制解析
let num2 = parseInt("10", 8); // 8，按八进制解析
let num3 = parseInt("10", 10); // 10，按十进制解析
let num4 = parseInt("10", 16); // 16，按十六进制解析
```

​ 因为不传底数参数相当于让 parseInt()自己决定如何解析，所以为避免解析出错，建议**始终传**给它第二个参数。

> 注意 多数情况下解析的应该都是十进制数，此时第二个参数就要传入 10。

​ parseFloat()函数的工作方式跟 parseInt()函数类似，都是从位置 0 开始检测每个字符。同样， 它也是解析到**字符串末尾**或者解析到一个**无效的浮点数值**字符为止。这意味着**第一次出现**的小数点是有 效的，但**第二次出现**的小数点就无效了，此时字符串的**剩余字符**都会被忽略。因此，"22.34.5"将转换 成 22.34。

​ parseFloat()函数的另一个不同之处在于，它**始终忽略**字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式(开头的零始终被忽略)。**十六进制数值始终会返回 0**。因为 parseFloat()**只解析十进制值**，因此**不能指定底数**。最后，如果字符串表示整数(没有小数点或者 数点后面只有一个零)，则 parseFloat()返回整数。下面是几个示例:

```javascript
let num1 = parseFloat("1234blue"); // 1234，按整数解析
let num2 = parseFloat("0xA"); // 0
let num3 = parseFloat("22.5"); // 22.5
let num4 = parseFloat("22.34.5"); // 22.34
let num5 = parseFloat("0908.5"); // 908.5
let num6 = parseFloat("3.125e7"); // 31250000
```
