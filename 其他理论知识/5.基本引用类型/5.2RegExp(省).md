## RegExp

​	ECMAScript 通过 RegExp 类型支持正则表达式。正则表达式使用类似 **Perl** 的简洁语法来创建:

```javascript
let expression = /pattern/flags;
```

​	这个正则表达式的 pattern(模式)可以是任何**简单或复杂**的正则表达式，包括**字符类、限定符、 分组、向前查找和反向引用**。每个正则表达式可以带**零个或多个 flags**(标记)，用于控制正则表达式的行为。下面给出了表示**匹配模式**的标记。

 - g:**全局**模式，表示查找字符串的**全部**内容，而不是找到第一个匹配的内容就结束。
 - i:**不区分大小写**，表示在查找匹配时**忽略 pattern 和字符串的大小写**。
 - m:**多行**模式，表示查找到一行**文本末尾时会继续查找**。
 - y:**粘附**模式，表示只查找从 **lastIndex 开始及之后的字符串**。
 - u:**Unicode** 模式，启用 **Unicode 匹配**。
 - s:**dotAll** 模式，表示**元字符**.匹配**任何字符(包括\n 或\r)**。

​	使用不同模式和标记可以创建出各种正则表达式，比如:

```javascript
// 匹配字符串中的所有"at" 
let pattern1 = /at/g;
// 匹配第一个"bat"或"cat"，忽略大小写 
let pattern2 = /[bc]at/i;
// 匹配所有以"at"结尾的三字符组合，忽略大小写
let pattern2 = /.at/gi;
```

​	与其他语言中的正则表达式类似，所有元字符在模式中也必须转义，包括:

```
([{\^$|)]}?*+.
```

​	元字符在正则表达式中都有一种或多种**特殊功能**，所以要**匹配**上面这些字符**本身**，就必须使用**反斜杠来转义**。下面是几个例子:

```javascript
// 匹配第一个"bat"或"cat"，忽略大小写 
let pattern1 = /[bc]at/i;
// 匹配第一个"[bc]at"，忽略大小写 
let pattern2 = /\[bc\]at/i;
// 匹配所有以"at"结尾的三字符组合，忽略大小写 
let pattern3 = /.at/gi;
// 匹配所有".at"，忽略大小写 
let pattern4 = /\.at/gi;
```

​	这里的 pattern1 匹配"bat"或"cat"，不区分大小写。要直接匹配"[bc]at"，左右中括号都必须像 pattern2 中那样使用**反斜杠转义**。在 pattern3 中，点号表示"at"前面的**任意字符都可以匹配**。 如果想匹配".at"，那么要像 pattern4 中那样对**点号进行转义**。

​	前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用 **RegExp 构造函数**来创建，它接收两个参数:**模式字符串**和(可选的)**标记字符串**。任何使用字面量定义的正则表达式也可以通过构造函数来创建，比如:

```javascript
// 匹配第一个"bat"或"cat"，忽略大小写 
let pattern1 = /[bc]at/i;
// 跟 pattern1 一样，只不过是用构造函数创建的 
let pattern2 = new RegExp("[bc]at", "i");
```

​	这里的 pattern1 和 pattern2 是**等效**的正则表达式。注意，RegExp 构造函数的**两个参数都是字符串**。因为 RegExp 的**模式参数**是字符串，所以在某些情况下需要**二次转义**。所有元字符都必须二次转义，包括转义字符序列，如\n(\转义后的字符串是\\\\，在**正则表达式字符串**中则要写成\\\\\\\\)。下表展示了几个正则表达式的**字面量形式**，以及使用 **RegExp 构造函数创建时对应的模式字符串**。

|     字面量模式     |         对应的字符串          |
| :----------------: | :---------------------------: |
|    /\\[bc\]at/     |       "\\\\[bc\\\\]at"        |
|      /\\.at/       |           "\\\\.at"           |
|    /name\/age/     |        "name\\\\/age"         |
|    /\d.\d{1,2}/    |       "\\\d.\\\\d{1,2}"       |
| /\w\\\hello\\\123/ | "\\\\w\\\\\\\hello\\\\\\\123" |

​	此外，使用 RegExp 也可以**基于已有**的正则表达式实例，并可**选择性地修改**它们的标记:

```javascript
const re1 = /cat/g;
console.log(re1); // "/cat/g"
const re2 = new RegExp(re1); 
console.log(re2); // "/cat/g"
const re3 = new RegExp(re1, "i"); 
console.log(re3); // "/cat/i"
```

### RegExp实例属性

​	每个 RegExp 实例都有下列属性，提供有关模式的各方面信息。

- global:布尔值，表示是否设置了 g 标记。
- ignoreCase:布尔值，表示是否设置了 i 标记。
- unicode:布尔值，表示是否设置了 u 标记。
- sticky:布尔值，表示是否设置了 y 标记。
- lastIndex:整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。