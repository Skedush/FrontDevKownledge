### 垃圾回收

​	JavaScript 是使用垃圾回收的语言，也就是说**执行环境负责**在**代码执行时管理内存**。在 **C 和 C++**等语言中，**跟踪内存使用**对开发者来说是个很大的负担，也是很多问题的来源。JavaScript 为开发者卸下了这个负担，通过**自动内存管理**实现**内存分配**和**闲置资源回收**。基本思路很简单:确定哪个变量不会再使用，然后**释放**它占用的内存。这个过程是**周期性**的，即垃圾回收程序**每隔一定时间**(或者说在代码执行过程中某个预定的收集时间)就会自动运行。垃圾回收过程是一个**近似且不完美的方案**，因为某块内存**是否还有用**，属于“**不可判定的**”问题，意味着**靠算法是解决不了**的。

​	我们以函数中**局部变量**的**正常生命周期**为例。函数中的局部变量会在**函数执行时存在**。此时，**栈(或堆)**内存会**分配空间**以保存相应的值。函数在内部使用了变量，然后退出。此时，就**不再需要那个局部变量**了，它占用的内存可以释放，供后面使用。这种情况下**显然不再需要局部变量**了，但并**不是所有时候都会这么明显**。垃圾回收程序必须**跟踪**记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略:**标记清理和引用计数**。

#### 标记清理

​	JavaScript **最常用**的垃圾回收策略是**标记清理**(mark-and-sweep)。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上**存在于上下文中的标记**。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当**变量离开上下文**时， 也会被加上**离开上下文的标记**。

​	给变量加标记的方式有很多种。比如，当变量**进入**上下文时，**反转**某一**位**;或者可以维护“在上下文中”和“不在上下文中”两个**变量列表**，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，**关键是策略**。

​	垃圾回收程序运行的时候，会**标记**内存中存储的**所有变量**(记住，标记方法有很多种)。然后，它会将所有在**上下文中的变量**，以及**被在上下文中的变量引用的变量**的标记**去掉**。在此之后再被**加上标记的变量**就是**待删除**的了，原因是**任何在上下文中的变量**都**访问不到**它们了。随后垃圾回收程序做一次内存清理，**销毁带标记**的所有值并收回它们的内存。

​	到了 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中**采用标记清理**(或其变体)，只是在运行垃圾回收的**频率**上有所差异。

#### 引用计数

​	另一种**没那么常用**的垃圾回收策略是引用计数(reference counting)。其思路是对每个值都**记录**它被**引用的次数**。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果**同一个值**又被**赋给另一个变量**，那么引用数**加 1**。类似地，如果保存对该值引用的**变量**被**其他值**给**覆盖**了，那么引用数**减 1**。当一 个值的**引用数为 0** 时，就说明没办法再访问到这个值了，因此可以安全地**收回**其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。

​	引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题:**循环引用**。所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。比如:

```javascript
function problem() {
  let objectA = new Object();
  let objectB = new Object();
  objectA.someOtherObject = objectB;
  objectB.anotherObject = objectA;
}
```

​	在这个例子中，objectA 和 objectB 通过各自的属性**相互引用**，意味着它们的引用数都是 2。在标记清理策略下，这不是问题，因为在函数结束后，这两个对象都不在作用域中。而在**引用计数策略**下，objectA 和 objectB 在函数结束后还会存在，因为它们的**引用数永远不会变成 0**。如果函数被多次调用，则会导致大量**内存永远不会被释放**。为此，Netscape 在 4.0 版**放弃了引用计数**，转而采用标记清理。 事实上，引用计数策略的问题还不止于此。

​	在 **IE8 及更早版本**的 IE 中，并非所有对象都是原生 JavaScript 对象。BOM 和 DOM 中的对象是 **C++ 实现的组件对象模型**(COM，Component Object Model)对象，而 COM 对象使用引用计数实现垃圾回收。因此，即使这些版本 IE 的 JavaScript 引擎使用标记清理，JavaScript 存取的 COM 对象依旧使用引用计数。换句话说，只要涉及 COM 对象，就无法避开循环引用问题。下面这个简单的例子展示了涉及 COM 对象的循环引用问题:

```javascript
let element = document.getElementById("some_element");
let myObject = new Object();
myObject.element = element;
element.someObject = myObject;
```

​	这个例子在一个 **DOM 对象**(element)和一个原生 **JavaScript 对象**(myObject)之间制造了**循环引用**。myObject 变量有一个名为 element 的属性指向 DOM 对象 element，而 element 对象有一个 someObject 属性指回 myObject 对象。由于存在循环引用，因此 **DOM 元素的内存永远不会被回收**， 即使它已经被从页面上删除了也是如此。

​	为避免类似的循环引用问题，应该在**确保不使用的情况**下**切断原生 JavaScript 对象与 DOM 元素之间的连接**。比如，通过以下代码可以**清除**前面的例子中建立的**循环引用**:

```javascript
myObject.element = null; 
element.someObject = null;
```

​	把变量设置为 null 实际上会**切断变量与其之前引用值之间的关系**。当下次垃圾回收程序运行时， 这些值就会被删除，内存也会被回收。

​	为了补救这一点，**IE9 把 BOM 和 DOM 对象都改成了 JavaScript 对象**，这同时也避免了由于存在**两套垃圾回收**算法而导致的问题，还**消除了常见的内存泄漏现象**。

> 注意 还有其他一些可能导致循环引用的情形，本书后面会介绍到。

#### 性能

​	垃圾回收程序会**周期性**运行，如果内存中**分配**了**很多变量**，则可能造成**性能损失**，因此垃圾回收的**时间调度**很重要。尤其是在**内存有限的移动设备**上，**垃圾回收**有可能会明显**拖慢渲染的速度和帧速率**。 开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到:无论什么时候开始收集垃圾，都能让它**尽快结束工作**。

​	现代垃圾回收程序会基于对 JavaScript 运行时**环境的探测来决定**何时运行。探测机制**因引擎而异**，但基本上都是根据**已分配对象的大小和数量**来判断的。比如，根据 V8 团队 2016 年的一篇博文的说法:“在一次完整的垃圾回收之后，V8 的**堆增长策略**会根据**活跃对象的数量**外加一些**余量**来确定何时再次垃圾回收。”

​	由于**调度垃圾回收程序**方面的问题会导致**性能下降**，IE 曾饱受诟病。它的策略是根据**分配数**，比如分配了 256 个变量、4096 个对象/数组字面量和数组槽位(slot)，或者 64KB 字符串。只要满足其中某个条件，垃圾回收程序就会运行。这样实现的问题在于，分配那么多变量的脚本，很可能在其**整个生命周期**内始终需要那么多变量，结果就会导致**垃圾回收程序过于频繁地运行**。由于对性能的严重影响，**IE7 最终更新了垃圾回收程序**。

​	IE7 发布后，JavaScript 引擎的垃圾回收程序被调优为**动态改变分配变量、字面量或数组槽位**等会触发垃圾回收的**阈值**。IE7 的起始阈值都与 IE6 的相同。如果**垃圾回收程序回收的内存不到已分配的 15%**， 这些变量、字面量或数组槽位的**阈值就会翻倍**。如果有一次回收的内存达到**已分配的 85%**，则**阈值重置为默认值**。这么一个简单的修改，极大地**提升**了重度依赖 JavaScript 的网页在浏览器中的**性能**。

> **警告** 在某些浏览器中是有可能(但不推荐)**主动触发垃圾回收**的。在 IE 中，window. CollectGarbage()方法会立即触发垃圾回收。在 Opera 7 及更高版本中，调用 window. opera.collect()也会启动垃圾回收程序。

#### 内存管理

​	在使用垃圾回收的编程环境中，开发者通常**无须关心内存管理**。不过，**JavaScript** 运行在一个内存管理与垃圾回收都很**特殊**的环境。分配给**浏览器**的内存通常比分配给**桌面软件**的要**少很多**，分配给**移动浏览器**的就**更少**了。这更多出于**安全考虑**而不是别的，就是为了避免运行大量 JavaScript 的网页**耗尽系统内存**而导致**操作系统崩溃**。这个内存限制不仅**影响变量分配**，也**影响调用栈**以及能够同时在**一个线程中执行的语句数量**。

​	将内存占用量**保持**在一个**较小的值**可以让**页面性能更好**。优化内存占用的**最佳手段**就是保证在**执行代码**时**只保存必要的数据**。如果数据不再必要，那么把它设置为 null，从而**释放**其引用。这也可以叫作**解除引用**。这个建议最**适合全局变量**和**全局对象的属性**。**局部变量**在超出作用域后会被**自动解除引用**， 如下面的例子所示:

```javascript
function createPerson(name) {
  let localPerson = new Object();
  localPerson.name = name;
  return localPerson;
}
let globalPerson = createPerson("Nicholas"); // 解除 globalPerson 对值的引用
globalPerson = null;
```



​	在上面的代码中，变量 globalPerson 保存着 createPerson()函数调用返回的值。在 createPerson() 内部，localPerson 创建了一个对象并给它添加了一个 name 属性。然后，localPerson 作为函数值被返回，并被赋值给 globalPerson。localPerson 在 createPerson()执行完成超出上下文后会自 动被解除引用，不需要显式处理。但 globalPerson 是一个全局变量，应该在**不再需要时手动解除其引用**，最后一行就是这么做的。

​	不过要注意，解除对一个值的引用并**不会**自动导致**相关内存**被**回收**。解除引用的关键在于**确保相关的值已经不在上下文里**了，因此它在**下次垃圾回收时**会被回收。

 1. 通过 **const** 和 **let** 声明提升性能

    ​	ES6 增加这两个关键字不仅有助于**改善代码风格**，而且同样有助于**改进垃圾回收的过程**。因为 const和 let 都以**块(而非函数)为作用域**，所以相比于使用 var，使用这两个新关键字可能会**更早地让垃圾回收程序介入**，**尽早回收**应该回收的内存。在块作用域比函数作用域**更早终止**的情况下，这就有可能发生。

 2. 隐藏类和删除操作

    ​	根据 JavaScript 所在的运行环境，有时候需要根据**浏览器使用的 JavaScript 引擎**来**采取不同的性能优化策略**。截至 2017 年，Chrome 是最流行的浏览器，使用 **V8 JavaScript 引擎**。V8 在将解释后的 JavaScript 代码编译为实际的机器码时会**利用“隐藏类”**。如果你的代码非常注重性能，那么这一点可能对你很重要。

    ​	运行期间，V8 会将**创建的对象与隐藏类关联起来**，以**跟踪**它们的**属性特征**。能够**共享相同隐藏类**的对象性能会**更好**，V8 会针对这种情况进行优化，但不一定总能够做到。比如下面的代码:

    ```javascript
    function Article() {
      this.title = "Inauguration Ceremony Features Kazoo Band";
    }
    let a1 = new Article();
    let a2 = new Article();
    ```

    ​	V8 会在后台**配置**，让这两个类实例**共享相同的隐藏类**，因为这两个实例共享**同一个构造函数和原型**。假设之后又添加了下面这行代码:

    ```javascript
    a2.author = 'Jake';
    ```

    ​	此时两个 Article 实例就会对应**两个不同的隐藏类**。根据这种**操作的频率**和**隐藏类的大小**，这有可能对**性能**产生**明显影响**。

    ​	当然，解决方案就是**避免** JavaScript 的“**先创建再补充**”(ready-fire-aim)式的**动态属性赋值**，并在构造函数中**一次性声明**所有属性，如下所示:

    ```javascript
    function Article(opt_author) {
      this.title = "Inauguration Ceremony Features Kazoo Band";
      this.author = opt_author;
    }
    let a1 = new Article();
    let a2 = new Article("Jake");
    ```

    ​	这样，两个实例基本上就一样了(**不考虑 hasOwnProperty 的返回值**)，因此可以**共享一个隐藏类**， 从而带来**潜在的性能提升**。不过要记住，使用 **delete 关键字**会导致**生成相同的隐藏类片段**。看一下这个例子:

    ```javascript
    function Article() {
      this.title = "Inauguration Ceremony Features Kazoo Band";
      this.author = "Jake";
    }
    let a1 = new Article();
    let a2 = new Article();
    delete a1.author;
    ```

    ​	在代码结束后，即使两个实例使用了同一个构造函数，它们也不再共享一个隐藏类。**动态删除属性**与**动态添加属性**导致的后果一样。最佳实践是**把不想要的属性设置为 null**。这样可以**保持隐藏类不变**和**继续共享**，同时也能达到**删除引用值供垃圾回收程序回收**的效果。比如:

    ```javascript
    function Article() {
      this.title = "Inauguration Ceremony Features Kazoo Band";
      this.author = "Jake";
    }
    let a1 = new Article();
    let a2 = new Article();
    a1.author = null;
    ```

 3. 内存泄漏

    ​	写得不好的 JavaScript 可能出现难以察觉且有害的**内存泄漏问题**。在**内存有限的设备**上，或者在**函数**会被**调用很多次**的情况下，内存泄漏可能是个大问题。JavaScript 中的内存泄漏大部分是由**不合理的引用**导致的。

    ​	**意外声明全局变量**是最常见但也最容易修复的内存泄漏问题。下面的代码没有使用任何关键字声明变量:

    ```javascript
    function setName() {
    	name = 'Jake';
    }
    ```

    ​	此时，解释器会把**变量 name 当作 window 的属性**来创建(相当于 window.name = 'Jake')。 可想而知，在 window 对象上创建的属性，只要 **window 本身不被清理就不会消失**。这个问题很容易解决，只要在变量声明前头加上 var、let 或 const **关键字**即可，这样变量就会在函数执行完毕后**离开作用域**。

    ​	定时器也可能会悄悄地导致内存泄漏。下面的代码中，定时器的回调**通过闭包**引用了外部变量:	

    ```javascript
    let myName = "Jake";
    setInterval(() => {
      console.log(myName);
    }, 100);
    ```

    ​	只要定**时器一直运行**，回调函数中引用的 name 就会一直**占用内存**。垃圾回收程序当然知道这一点，因而就**不会清理外部变量**。

    ​	使用 JavaScript **闭包**很容易在不知不觉间造成内存泄漏。请看下面的例子:

    ```javascript
    let outer = function () {
      let name = "Jake";
      return function () {
        return name;
      };
    };
    ```

    ​	调用outer()会导致分配给name的内存被泄漏。以上代码执行后创建了一个**内部闭包**，只要**返回的函数存在**就**不能清理 name**，因为**闭包一直在引用着它**。假如 name 的内容很大(不止是一个小字符串)，那可能就是个大问题了。

 4. 静态分配与对象池

    ​	为了提升 JavaScript 性能，最后要考虑的一点往往就是压榨浏览器了。此时，一个关键问题就是如何**减少浏览器执行垃圾回收的次数**。开发者**无法直接控制**什么时候开始收集垃圾，但可以**间接控制触发**垃圾回收的条件。理论上，如果能够**合理使用分配的内存**，同时**避免**多余的垃圾回收，那就可以保住因**释放内存而损失的性能**。

    ​	浏览器决定何时运行垃圾回收程序的一个标准就是**对象更替的速度**。如果有**很多对象被初始化**，然后**一下子又都超出了作用域**，那么浏览器就会采用**更激进的方式调度**垃圾回收程序运行，这样当然会影响性能。看一看下面的例子，这是一个计算二维矢量加法的函数:

    ```javascript
    function addVector(a, b) {
      let resultant = new Vector();
      resultant.x = a.x + b.x;
      resultant.y = a.y + b.y;
      return resultant;
    }
    ```

    ​	调用这个函数时，会在堆上创建一个新对象，然后修改它，最后再把它返回给调用者。如果这个**矢量对象的生命周期**很短，那么它会很快**失去所有对它的引用**，成为可以**被回收**的值。假如这个矢量加法函数**频繁被调用**，那么垃圾回收调度程序会发现这里**对象更替的速度很快**，从而会更**频繁地安排垃圾回收**。

    ​	该问题的解决方案是**不要动态创建矢量对象**，比如可以修改上面的函数，让它使用一个**已有的矢量对象**:

    ```javascript
    function addVector(a, b, resultant) {
      resultant.x = a.x + b.x;
      resultant.y = a.y + b.y;
      return resultant;
    }
    ```

    ​	当然，这需要在**其他地方实例化矢量参数** resultant，但这个函数的行为没有变。那么在哪里创建矢量可以不让垃圾回收调度程序盯上呢?

    ​	一个策略是**使用对象池**。在初始化的某一时刻，可以**创建一个对象池**，用来**管理一组可回收的对象**。 应用程序可以向这个对象池**请求一个对象、设置其属性、使用它**，然后在**操作完成后再把它还给对象池**。 由于**没发生对象初始化**，**垃圾回收探测**就**不会发现有对象更替**，因此垃圾回收程序就不会那么频繁地运行。下面是一个对象池的伪实现:

    ```javascript
    // vectorPool 是已有的对象池
    let v1 = vectorPool.allocate();
    let v2 = vectorPool.allocate();
    let v3 = vectorPool.allocate();
    v1.x = 10;
    v1.y = 5;
    v2.x = -3;
    v2.y = -6;
    addVector(v1, v2, v3);
    console.log([v3.x, v3.y]); // [7, -1]
    vectorPool.free(v1);
    vectorPool.free(v2);
    vectorPool.free(v3);
    // 如果对象有属性引用了其他对象
    // 则这里也需要把这些属性设置为null
    v1 = null;
    v2 = null;
    v3 = null;
    ```

    ​	如果对象池只**按需分配矢量**(在对象**不存在时创建新的**，在对象**存在时则复用存在的**)，那么这个实现**本质**上是一种**贪婪算法**，有**单调增长**但为**静态的内存**。这个对象池必须**使用某种结构维护所有对象**，数组是比较好的选择。不过，使用数组来实现，必须留意不要招致额外的垃圾回收。比如下面这个例子:

    ```javascript
    let vectorList = new Array(100); 
    let vector = new Vector(); 
    vectorList.push(vector);
    ```

    ​	由于 JavaScript **数组的大小**是**动态可变**的，引擎会**删除大小为 100 的数组**，再**创建一个新的大小为 200 的数组**。垃圾回收程序会看到这个删除操作，说不定因此很快就会跑来收一次垃圾。要**避免**这种**动态分配**操作，可以在初始化时就创建一个**大小够用的数组**，从而避免上述先删除再创建的操作。不过， 必须事先想好这个数组有多大。

    > **注意** 静态分配是优化的一种**极端形式**。如果你的应用程序被垃圾回收严重地拖了后腿， 可以利用它提升性能。但这种情况并不多见。大多数情况下，这都属于**过早优化**，因此**不用考虑**。

### 小结

​	JavaScript 变量可以保存两种类型的值:原始值和引用值。原始值可能是以下 6 种原始数据类型之 一:Undefined、Null、Boolean、Number、String 和 Symbol。原始值和引用值有以下特点。

 - 原始值**大小固定**，因此保存在**栈内存**上。
 - 从一个变量到另一个变量复制原始值会创建该值的第二个**副本**。
 - 引用值是**对象**，存储在**堆内存**上。
 - 包含引用值的变量实际上只包含**指向相应对象**的一个**指针**，而**不是对象本身**。
 - 从一个变量到另一个变量复制引用值只会**复制指针**，因此结果是两个变量都**指向同一个对象**。
 - **typeof** 操作符可以**确定值的原始类型**，而 **instanceof** 操作符用于**确保值的引用类型**。

​	任何变量(不管包含的是原始值还是引用值)都**存在于某个执行上下文中**(也称为作用域)。这个上下文(作用域)**决定了变量的生命周期**，以及它们可以**访问代码的哪些部分**。执行上下文可以总结 如下。

	- 执行上下文分**全局上下文、函数上下文和块级上下文**。
	- 代码执行流每进入一个新上下文，都会创建一个**作用域链**，用于**搜索变量和函数**。
	- 函数或块的局部上下文不仅可以**访问自己作用域内的变量**，而且也可以访问任何**包含上下文**乃至**全局上下文**中的变量。
	- 全局上下文**只能访问全局上下文**中的**变量和函数**，**不能直接访问局部上下文**中的任何数据。
	- 变量的**执行上下文**用于**确定**什么时候**释放内存**。

​	JavaScript 是使用垃圾回收的编程语言，**开发者不需要操心内存分配和回收**。JavaScript 的垃圾回收程序可以总结如下。

 - **离开作用域的值**会被**自动标记为可回收**，然后在**垃圾回收期间被删除**。
 - **主流**的垃圾回收**算法**是**标记清理**，即先给当前**不使用的值加上标记**，再回来回收它们的内存。
 - **引用计数**是另一种垃圾回收策略，需要**记录**值被**引用了多少次**。JavaScript 引擎**不再使用**这种算 法，但某些**旧版本的 IE** 仍然会受这种算法的影响，原因是 JavaScript 会访问**非原生 JavaScript 对象**(如 DOM 元素)。
 - 引用计数在代码中存在**循环引用**时会出现问题。
 - **解除变量的引用**不仅可以**消除循环引用**，而且对**垃圾回收也有帮助**。为促进内存回收，**全局对象、全局对象的属性和循环引用**都应该在**不需要时解除引用**。













